---
title: Interpolation
---

## Slerp

在**四元数所定义的 4 维单位球面**（unit hypersphere）上，沿**大圆弧**等速地从一个旋转过渡到另一个旋转。它和普通的线性插值（Lerp）有本质区别




## Lerp

$$

\text{Lerp}(a, b, t) = (1 - t)\,a + t\,b,\quad t\in[0,1].

$$

  

同样地，对四元数直接做 Lerp：

```cpp

glm::quat q = (1 - t) * q1 + t * q2;

q = glm::normalize(q);

```

  

* **优点**：实现简单、计算快。

* **缺点**：

* 虽然最后做了 `normalize`，但插值轨迹是在 4D 空间里一条“直线”——并**不**是球面上的大圆。

* 会导致转速不恒定（先慢后快再慢），画面感觉会“加速减速”，而且在插值区间较大时可能出现“抖动”或“偏移”效果。

  

---

  

## 2. 球面插值（Slerp）的原理

  

* **思路**：把两个单位四元数 $q_1, q_2$ 看成 4 维单位球面上的两点，用沿球面的大圆（geodesic）做等速插值。

  

* **公式**：

  

$$

\text{Slerp}(q_1, q_2, t)

= \frac{\sin\big((1 - t)\,\omega\big)}{\sin \omega}\,q_1

\;+\;\frac{\sin(t\,\omega)}{\sin \omega}\,q_2,

$$

  

其中

$\omega = \arccos\big(\langle q_1, q_2\rangle\big)$

是两点在球面上的“夹角”，$\langle\cdot,\cdot\rangle$ 是四元数的点积。

  

* **特性**：

  

1. **等速**：沿球面大圆的弧长匀速移动，视觉上感觉匀速旋转。

2. **最短路径**：总是沿两旋转之间最近的大圆弧过渡，不绕远路。

3. **无扭曲**：始终保持单位四元数，无须后续归一化，也不会出现突兀的“翻转”或“抖动”。

  

---

  

## 3. 代码对比

  

```cpp

// 1. 直接 Lerp + Normalize （不推荐过渡动画）

glm::quat q_lerp = glm::normalize((1 - t) * q1 + t * q2);

  

// 2. Slerp （推荐用于平滑旋转）

glm::quat q_slerp = glm::slerp(q1, q2, t);

```

  

* **`glm::slerp`** 内部就是按上面大圆弧公式实现的。

* 在 t 从 0→1 的过程中，`q_slerp` 保证等速、最短路径。

  

---

  

## 4. 视觉对比示例

  

| t 值 | Lerp（归一化后） | Slerp |

| ------- | --------------- | --------------------- |

| t = 0.0 | q → 准确等于 q1 | q → 准确等于 q1 |

| t = 0.5 | 可能偏离大圆轨迹，速度快慢不一 | 刚好在两点大圆弧中点，旋转角度 = ω/2 |

| t = 1.0 | q → 准确等于 q2 | q → 准确等于 q2 |

  

* **Lerp**：如果 $\omega$ 很大，插值会绕球面“穿过”内部，产生不自然的“曲线”过渡。

* **Slerp**：始终在球面“表面”匀速行走，保证了旋转的平滑与自然。

  

---

  

## 5. 何时用 Slerp

  

* **相机姿态过渡**：从一个方向平滑过渡到另一个方向，避免“抖动”或“速度不均匀”。

* **物体旋转动画**：比如角色转身、机械臂摆动，希望匀速、无障碍。

* **骨骼动画**：骨骼关节插值，用 Slerp 往往比 Euler 角插值更稳定。

* **虚拟现实**：头部追踪、视点切换等场景，需要极为平滑的旋转体验。

  

---

  

### 小结

  

* **Lerp + Normalize**：实现简单，但在大角度过渡时会有不匀速或抖动。

* **Slerp**：沿单位球面大圆匀速插值，最短路径，视觉最平滑自然。

  

推荐在所有需要可视旋转动画或相机过渡的场景，都优先使用 `glm::slerp(q1, q2, t)`，这样能保证最佳的视觉效果和数值稳定性。